moldyn-data-iter-reord.txt
--------------------------
Started 7/16/08

Showing all the details of how to automatically generate the inspector and executor for a data reordering followed by an iteration reordering on the following code:

    for (ii=0; ii<n_inter; ii++) {
        // simplified computations
        fx[inter1[ii]] += x[inter1[ii]] - x[inter2[ii]]; 
        fx[inter2[ii]] += x[inter1[ii]] - x[inter2[ii]]; 
    }

Notes
    - moldyn-FST.txt is an earlier version of this.  Main difference is that now we have the transformations clearly separated from optimization such as pointer update and array alignment.
    
    - detail for the algorithms referenced in here can be found in uninterp-operations.txt
    
    
-----------------------
What the user specifies
-----------------------
Iteration Space
    I_0 := { [ii,1] : 0 <= ii <= (n_inter-1)  }
           union { [ii,2] : 0 <= ii <= (n_inter-1)  }

Symbolic Constants
    N                   // number of atoms
    n_inter             // number of interactions between atoms
    
    // uninterp functions for index arrays, 
    // [0..(n_inter-1)] indicates range of possible parameter values
    // [0:N] indicates range of possible values
    // FIXME: might want to use this approach of representing IndexArray
    // constraints versus using the OmegaRelation that we currently have
    // in the MapIR design.
    inter1([0..(n_inter-1)]):[0..N]    
    inter2([0..(n_inter-1)]):[0..N]    
                        

Data Spaces
    X_0 := name = "x", { [k] : 0 <= k <= (N-1) }, data array
    FX_0 := name = "fx", { [k] : 0 <= k <= (N-1) }, data array
    INTER1_0 := name = "inter1", { [k] : 0 <= k <= (n_inter-1) }, index array
    INTER2_0 := name = "inter2", { [k] : 0 <= k <= (n_inter-1) }, index array

Statements
    [ii,1]  "`a1 += `a2 - `a3;" 
    [ii,2]  "`a4 += `a5 - `a6;" 


Access Relations
    These actually need to be specified per data access in each statement.

    statement   access#     DataSpace   AccessRelation
    [ii,1]      a1           FX_0        { [ii,1] -> [ inter1(ii) ] }
    [ii,1]      a2           X_0         { [ii,1] -> [ inter1(ii) ] }
    [ii,1]      a3           X_0         { [ii,1] -> [ inter2(ii) ] }
    
    [ii,2]      a4           FX_0        { [ii,1] -> [ inter2(ii) ] }
    [ii,2]      a5           X_0         { [ii,1] -> [ inter1(ii) ] }
    [ii,2]      a6           X_0         { [ii,1] -> [ inter2(ii) ] }
    
    // summary access relations are the union of all access relations
    // to a particular data space
    // These can actually be generated automatically by using unions
    // between access relations that access the same data array.
    A_I_0_to_X_0 := name = "A_I_0_to_X_0",{ [ii,j] -> [ inter1(ii) ] : 1<=j<=2 } 
                   union { [ii,j] -> [ inter2(ii) ] : 1<=j<=2 }
                   
    A_I_0_to_FX_0 := name = "A_I_0_to_FX_0", { [ii,1] -> [ inter1(ii) ] } 
                   union { [ii,2] -> [ inter2(ii) ] }

    // Do we also want summary access relations for the index arrays?
    A_I_0_to_INTER1_0 := name = "A_I_0_to_INTER1_0", { [ii,1] -> [ ii ] } 
                       union { [ii,2] -> [ ii ] }
                       
    A_I_0_to_INTER2_0 := name = "A_I_0_to_INTER2_0", { [ii,1] -> [ ii ] } 
                       union { [ii,2] -> [ ii ] }

Data Dependences
    Only reduction dependences.  It is important to indicate that there are reduction dependences however, because that means each iteration needs to be executed atomically if the loop is being parallelized.
    FIXME: how will we indicate reduction dependences?

Composition and choice of RTRTs
    data reordering
        DataPermuteRTRT
            data_reordering = { [ k ] -> [ sigma( k ) ] }
            iteration_space = I_0
            data_spaces = [ X_0, FX_0 ]
            access_relation = A_I0_to_X0
            iter_sub_space_relation = { [ ii, j ] -> [ ii ] }
            iag_func_name = CPackHyper
            iag_type = IAG_Permute
    
    Naming standards
        After any transformation, we are going to assume that a space with the subscript n will be transformed into the same named space with the subscript n+1.  For example I_0 will become I_1.
    
    iteration reordering
        IterPermuteRTRT
            iter_reordering = { [ i ] -> [ delta( i ) ] }
            iteration_space = I_1
            access_relation = A_I0_to_X0
            iter_sub_space_relation = { [ ii, j ] -> [ ii ] }
            iag_func_name = LexMin
            iag_type = IAG_Permute
            
------------------------------------------------------------
Automatically Generating Straight-Forward Inspector/Executor
------------------------------------------------------------
