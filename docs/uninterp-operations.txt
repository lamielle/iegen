uninterp-operations.txt

Notes on the various presburger set and relation options and how we can implement them if we are manipulating presburger sets with uninterpreted functions.

==================================================== Algorithms =======
--------
Notation
--------
w, x, y, z - integer variable tuples, or vectors
c# - constraints

---------------------------------------------
Comparison between two uninterp function uses
---------------------------------------------
f(a_1, a_2, ..., a_p) =?= g(b_1, b_2, ..., b_k)
It is possible to indicate that two uninterp function uses are equal if the same function is being called (f==g), the same number of parameters are being passed (p==k), and all of the actual parameters are the same (a_i==b_i).  If that is not the case then their equality is unknown.


---------------------------------
Composition between two relations
---------------------------------
R1 := { x -> y : c1 }
R2 := { w -> z : c2 }
R2 compose R1 = R2(R1) = { x -> z : w = y && c1 && c2 }

Correctness
    - arity(w) = arity(y)
Assumptions
    - c1 and c2 do not involve existentially quantified variables


--------------
Collapsing Index Arrays
--------------
Examples include pointer update and array alignment.

Pointer update motivation: makes it so explicit construction of the data mapping is cheaper and improves the performance in the executor code.

Array alignment: same motivation.
If an array (either data and/or index) is directly accessed by a loop iterator and that loop is permuted, then data alignment applied afterwards essentially turns an iteration reordering into a data reordering.


Given two index arrays, pointer update creates a new index array that is the composition of the two index arrays.
new_iag = iag1[ iag2[ i ] ]

Correctness
    - Bounds on values for iag2 should like within bounds on input values for iag1.
    
Could we use code gen for Relations to implement the construction of new_iag?
{[i] -> [j] : j = iag1( iag2( i ) ) && bounds for input to iag2 };
If so this would be another example like Hypergraph construction that needs us to generate the loop to iterate over the input tuples and then generate code to provide the output tuple results for a given input tuple value. 

Implementation of pointer update
    PU0) find access relations with nested uninterpreted functions 
    PU1) create relation for each nest
    PU2) generate code to generate new_iag
    PU3) use definition of new_iag to replace compositions of two index arrays in any sets and/or relations


---------------------
Iteration Permutation
---------------------
Implement an iteration permutation by modifying the data access relations with the inverse iteration permutation.  An iteration permutation can be performed on some subspace of the iteration space, but for now we are assuming that that subspace only has one iterator.

    IP1) For all instances of the iterator being permuted in the access relations replace the iterator with delta_inv(i), where i is the iterator and delta_inv is the inverse of the loop permutation.


---------------------
Data Alignment
---------------------
Data alignment can be more general than that however.  Actually pointer update and data alignment are the same ITO (inter-transformation optimization).  They both take nested index array accesses and collapse them by one or more levels.


Algorithm:
    IP1) For all access relations where the access relation is the identity function, implement the iteration permutation with a data permutation on the target data spaces.   
    
    IP2) For each of these, create an identity 
            new_iag(i) = old_iag( delta_inv( i ) ).
    
    IP3) If there are any where the access relation is not the identity, then create the iag which is the inverse of the iteration reordering, and replace the iterator in the access relation with the iteration reordering inverse of that iterator.
    IOW, replace all uses of iterator i for loop being permuted with delta_inv(i).
    
    IP4) Wherever possible use the new_iag equalities created in step (1) to simplify the resulting access relations.
    

----------------
Code Gen for Set
----------------

---------------------
Code Gen for Relation
---------------------
For pointer graph and explicit generation of a Hypergraph, we need to be able to generate code that iterates over the input tuples in a relation and generates the corresponding output tuple values.

    Algorithm:
        - simplify relation
        - gather all affine inequality constraints for input tuple variables
        - send constraints to omega or Cloog code gen for loop code gen (ALAN?)
        - for each output tuple variable use equality constraints to generate code that calculates their values in terms of the input variables and put in statement macro
        
    Might want to break the above into two pieces:
        - generating code that iterates over the input tuple vars
        - generate code that given the input tuple vars calculates the output tuple vars
        
    FIXME
        - if there are 2+ conjuncts, can we always assume that the input tuple for each of those in the conjunct are the same?
        
--------------
Simplification
--------------
After we do any of the above specified operations, we are going to have some free variables in the resulting constraints.  These free variables are implicitly existentially quantified.  

We think we need to get rid of them, because they complicate code gen if they are in sets and the complicate further operations if they are in relations.
FIXME: need some examples of these two things

S1) Removing equalities between a variable and an expr
    For each equality involving a variable and a constant, v=e or e=v
    What to do this for all non-tuple variables
        Replace v with the expression in the rest of the constraints.
        Remove v=e from the constraints

S2) Removing inequalities. v <= e or v >= e
    If v is only involved in inequalities where e is constant or a scalar symbolic constant, then remove all inequalities involving v.
    
S3) Remove variable by creating the inverse of a permutation.
    If have an existential variable that is input to two or more uninterpreted function symbols and at least one of them is a non-nested uninterp function where the associated index array is a permutation, then solve for existential variable using the inverse of the permutation.  Then apply S1 to eliminate existential variable in other places where it is an input.

==================================================== Examples =========

---------
Example 1: composition with relations 
---------
// from moldyn-FST.txt, restricting iteration space in access relation
R1 := { [ a, b ] -> [ c ] : c=a }
R2 := { [ k ] -> [ ii, 1 ] : k=inter1(ii) } union ...

R1 ( R2 ) = { [ k ] -> [ c ] : a=ii && b=1 && c=a && k=inter1(ii) }
            union ...
            
// applying S1 to a=ii, expr=ii
R1 ( R2 ) = { [ k ] -> [ c ] : b=1 && c=a && k=inter1(a) }
            union ...
            
// applying S1 to c=a, expr=a
R1 ( R2 ) = { [ k ] -> [ c ] : b=1 && k=inter1(c) }
            union ...

// applying S1 to b=1, expr=1
R1 ( R2 ) = { [ k ] -> [ c ] : k=inter1(c) }
            union ...


---------
Example 2: composition with relations
---------
// from moldyn-FST.txt, applying data reordering to access relation              
data_reordering := {[j] -> [f] : f = sigma(j) }
A_I0_to_X0 := {  [ ii, 1 ] -> [ k ] : k=inter1(ii) } union ...
        
data_reordering(A_I0_to_X0) = { [ii,1] -> [f] : j=k && f = sigma(j) && k=inter1(ii) } union ...
        
// applying S1 to j=k, expr=k
data_reordering(A_I0_to_X0) = { [ii,1] -> [f] :  f = sigma(j) && j=inter1(ii) } union ...
        
// applying S1 to j=inter1(ii), expr=inter1(ii)       
data_reordering(A_I0_to_X0) = { [ii,1] -> [f] :  f = sigma(inter1(ii)) } union ...
        
// applying pointer update, inter1'(i) = sigma(inter1(i))
data_reordering(A_I0_to_X0) = { [ii,1] -> [f] :  f = inter1'(i) } union ...


---------
Example 3: composition with relations
---------
// from moldyn-FST.txt, iteration reordering example
iter_reordering := { [i,j] -> [k,j] : k=delta(i) };
I_1 := { [ii,1] : 0 <= ii <= (n_inter-1)  } union ...
                   
iter_reordering( I_1 ) = {[k,j] : i=ii && j=1 && 0 <= ii <= (n_inter-1) &&  k=delta(i) } union ...

// applying S1 to remove i==ii
iter_reordering( I_1 ) = {[k,j] : j=1 && 0 <= i <= (n_inter-1) &&  k=delta(i) } union ...

        //FIXME
        // ok now the problem is that ii is existentially quantified, 
        // it is involved in inequalities and in an uninterp equality
        
// Possible solution: iteration permutation 
iter_reordering := { [i,j] -> [k,j] : k=delta(i) };
I_1 := { [ii,1] : 0 <= ii <= (n_inter-1)  } union ...
A_I1_to_INTER1_0 := name = "A_I1_to_INTER1_0", { [ii,1] -> [ ii ] } 
                   union { [ii,2] -> [ ii ] }
A_I1_to_X1 := name = "A_I1_to_X1", { [ii,j] -> [ sigma(inter1(ii)) ] : 1<=j<=2 } 
              union { [ii,j] -> [ sigma(inter2(ii)) ] : 1<=j<=2 }
                   
// do step IP1
for A_I1_to_INTER1_0 and A_I1_to_INTER1_1
create DataPermuteRTRT
        data_reordering = {[k] -> [delta(k)] }
        iteration_space = I_1
        data_spaces = [ INTER1_0, INTER2_0 ]
        access_relation = none
        iter_sub_space_relation = none
        iag_func_name = none
        iag_type = none
        
// step IP2
    inter1_1(i) = inter1(delta_inv(i))
    inter2_1(i) = inter2(delta_inv(i))

// step IP3
for A_I1_to_X1 and A_I1_to_FX1
    A_I2_to_X1 := name = "A_I2_to_X1", { [ii,j] -> [ sigma(inter1(delta_inv(ii))) ] : 1<=j<=2 } 
              union { [ii,j] -> [ sigma(inter2(delta_inv(ii))) ] : 1<=j<=2 }

// step IP4
    A_I2_to_X1 := name = "A_I2_to_X1", 
              { [ii,j] -> [ sigma(inter1_1(ii)) ] : 1<=j<=2 } 
              union { [ii,j] -> [ sigma(inter2_1(ii)) ] : 1<=j<=2 }
              

    