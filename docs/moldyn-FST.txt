moldyn-FST.txt
--------------
NOTE: see moldyn-FST.in for omega calculator commands used to play with example in this file.


Goals
1) How would the composed inspector and executor be generated if we use a library approach where data dependences and data mappings are explicitly generated as hypergraphs?
    Subgoal:
        -get a data and iteration reordering composition working


----------------------
Index Array Generators
----------------------
BFSHyper
    Input:
        hypergraph and dual
    Output:
        Permutation of nodes in hypergraph
        
CPack
    Input:
        hypergraph
    Output:
        Permutation of hyperedges in hypergraph


---------------------
Transformation Writer
---------------------
    Data reordering RTRT
        Constraints: 
            -1D data space
            -No dependences between index arrays, or uninterpreted function symbols used to represent them.  Is this an issue?  See 1D iteration space below.
            -Perfectly nested loop?  1D loop?
        Possible IAGS:
            list these
        Input: 
            -Data mapping relation
            -Select IAG
        Output:
            -Permutation mapping for data
            
    Iteration reordering RTRT
        Constraints:
            -1D iteration space?  I don't think this is necessary because the inspector can generate hypergraph representing computation no matter what.  Is the problem generating the transformed executor?
        Possible IAGS:
            list these
        Input:
            -Data mapping relation
            -Select IAG
        Output:
            -Permuation mapping for data
    
    SparseTiling RTRT
    Tile Packing RTRT
    
-----------------------
What the user specifies
-----------------------
Code
    for (ii=0; ii<n_inter; ii++) {
        // simplified computations
        fx[inter1[ii]] += x[inter1[ii]] - x[inter2[ii]]; 
        fx[inter2[ii]] += x[inter1[ii]] - x[inter2[ii]]; 
    }

Iteration Space
    I_0 := { [ii,1] : 0 <= ii <= (n_inter-1)  }
          union { [ii,2] : 0 <= ii <= (n_inter-1)  }

Data Spaces
    X_0 := { [k] : 0 <= k <= (N-1) }, data array
    FX_0 := { [k] : 0 <= k <= (N-1) }, data array
    INTER1_0 := { [k] : 0 <= k <= (n_inter-1) }, index array
    INTER2_0 := { [k] : 0 <= k <= (n_inter-1) }, index array

Index Array Value Constraints
    // if (0 <= ii <= (n_iter-1)) then (0 <= inter1(ii) <= (N-1))
    { [ii] -> [inter1(ii)] : not (0 <= ii <= (n_inter-1)) || (0 <= inter1(ii) <= (N-1)) }
    
    // if (0 <= ii <= (n_iter-1)) then (0 <= inter2(ii) <= (N-1))
    { [ii] -> [inter2(ii)] : not (0 <= ii <= (n_inter-1)) || (0 <= inter2(ii) <= (N-1)) }   
        

Access Relations
    A_II0_to_X0 := { [ii,1] -> [ inter1(ii) ] } 
                   union { [ii,1] -> [ inter2(ii) ] }
                   
    A_II0_to_FX0 := { [ii,1] -> [ inter1(ii) ] } 
                   union { [ii,2] -> [ inter2(ii) ] }


Data Dependences
    Only reduction dependences.

Composition and choice of RTRTs
    data reordering
        DataPermuteRTRT
            data_reordering = { [ k ] -> [ sigma( k ) ] }
            iteration_space = I_0
            data_spaces = [ X_0, FX_0 ]
            access_relation = A_II0_to_X0
            iter_sub_space_relation = { [ ii, j ] -> [ ii ] }
            index_array_generator = CPACK
    
    iteration reordering

-------------------------
ITOs and other automation
-------------------------

Generating the composed inspector

    1) DataPermuteRTRT
        a) restrict access_relation to iteration subspace
            input:
                access_relation
                iter_sub_space_relation

            output:
                relation_to_traverse = inverse ( iter_sub_space_relation compose (inverse access_relation))
                
            For the example, output is the following:
                relation_to_traverse := { [ii] -> [ inter1(ii) ] } 
                                       union { [ii] -> [ inter2(ii) ] }
            
        b) restrict iteration space to iteration subspace
            input:
                I_0     // original iteration space
                iter_sub_space_relation
            output:
                iter_sub_space = iter_sub_space_relation ( I_0 )
                
            For the example, output is the following:
                iter_sub_space = { [ii] : 0 <= ii < n_inter  }
                                 
                
        c) generate code that explicitly creates hypergraph and dual (if necessary) at runtime.
            input:
                iter_sub_space
                relation_to_traverse
            output:
                code
                    // loop that traverses iter_sub_space
                    for ...
                        S1(i_1, ..., i_d);
           
            For the example, output is the following:
                    // this specific example
                    for(t1 = 0; t1 <= n_inter-1; t1++) {
                        s1(t1);
                    }

                        
            algorithm:
                1) use omega codegen to generate loop over iteration sub space
                    codegen iter_sub_space;
                    
                2) generate a macro definition for the statement in the loop body from the relation_to_traverse
                    a) for each conjunct in the DNF // seem omega lib docs
                         -gen code that solves for the out variable, data_index, using the input iterator values
                         -gen code that makes the following call:
                            Hypergraph_ordered_insert_node( hgraph, iter_count, data_index )


LEFTOFF: 
    - what should the interface for the hypergraph data structure be?
    - create the hypergraph data structure based on hypergraph code I already have
    - part (d) of the DataPermuteRTRT requires that the generated hypergraph be passed to the specified IAG
    - then we have to figure out whether to actually reorder the data or not and whether to do the pointer update.     
    
    