moldyn-FST.txt
--------------
NOTE: see moldyn-FST.in for omega calculator commands used to play with example in this file.


Goals
1) How would the composed inspector and executor be generated if we use a library approach where data dependences and data mappings are explicitly generated as hypergraphs?
    Subgoal:
        -get a data and iteration reordering composition working


----------------------
Index Array Generators
----------------------
BFSHyper
    Input:
        hypergraph and dual
    Output:
        Permutation of nodes in hypergraph
        
CPack
    Input:
        hypergraph
    Output:
        Permutation of hyperedges in hypergraph


---------------------
Transformation Writer
---------------------
    Data reordering RTRT
        Constraints: 
            -1D data space
            -No dependences between index arrays, or uninterpreted function symbols used to represent them.  Is this an issue?  See 1D iteration space below.
            -Perfectly nested loop?  1D loop?
        Possible IAGS:
            list these
        Input: 
            -Data mapping relation
            -Select IAG
        Output:
            -Permutation mapping for data
            
    Iteration reordering RTRT
        Constraints:
            -1D iteration space?  I don't think this is necessary because the inspector can generate hypergraph representing computation no matter what.  Is the problem generating the transformed executor?
        Possible IAGS:
            list these
        Input:
            -Data mapping relation
            -Select IAG
        Output:
            -Permuation mapping for data
    
    SparseTiling RTRT
    Tile Packing RTRT
    
-----------------------
What the user specifies
-----------------------
Code
    for (ii=0; ii<n_inter; ii++) {
        // simplified computations
        fx[inter1[ii]] += x[inter1[ii]] - x[inter2[ii]]; 
        fx[inter2[ii]] += x[inter1[ii]] - x[inter2[ii]]; 
    }

Iteration Space
    I_0 := { [ii,1] : 0 <= ii <= (n_inter-1)  }
          union { [ii,2] : 0 <= ii <= (n_inter-1)  }

Data Spaces (probably need a name field for these as well so can match with uninterpreted function symbols.  For now use the same string for the name and UFS.
    X_0 := name = "x", { [k] : 0 <= k <= (N-1) }, data array
    FX_0 := name = "fx", { [k] : 0 <= k <= (N-1) }, data array
    INTER1_0 := name = "inter1", { [k] : 0 <= k <= (n_inter-1) }, index array
    INTER2_0 := name = "inter2", { [k] : 0 <= k <= (n_inter-1) }, index array

Index Array Value Constraints
    // if (0 <= ii <= (n_iter-1)) then (0 <= inter1(ii) <= (N-1))
    { [ii] -> [inter1(ii)] : not (0 <= ii <= (n_inter-1)) || (0 <= inter1(ii) <= (N-1)) }
    
    // if (0 <= ii <= (n_iter-1)) then (0 <= inter2(ii) <= (N-1))
    { [ii] -> [inter2(ii)] : not (0 <= ii <= (n_inter-1)) || (0 <= inter2(ii) <= (N-1)) }   
        

Access Relations
    A_II0_to_X0 := name = "A_II0_to_X0", { [ii,1] -> [ inter1(ii) ] } 
                   union { [ii,1] -> [ inter2(ii) ] }
                   
    A_II0_to_FX0 := name = "A_II0_to_FX0", { [ii,1] -> [ inter1(ii) ] } 
                   union { [ii,2] -> [ inter2(ii) ] }


Data Dependences
    Only reduction dependences.  It is important to indicate that there are reduction dependences however, because that means each iteration needs to be executed atomically.

Composition and choice of RTRTs
    data reordering
        DataPermuteRTRT
            data_reordering = { [ k ] -> [ sigma( k ) ] }
            iteration_space = I_0
            data_spaces = [ X_0, FX_0 ]
            access_relation = A_II0_to_X0
            iter_sub_space_relation = { [ ii, j ] -> [ ii ] }
            iag_func_name = IAG_cpack
            iag_type = IAG_Permute
           
    

    
    
    iteration reordering

-------------------------
ITOs and other automation
-------------------------

Generating the composed inspector

    1) DataPermuteRTRT
        a) restrict access_relation to iteration subspace
            input:
                access_relation
                iter_sub_space_relation

            output:
                access_relation_to_traverse = new AccessRelation
                    name = access_relation.name
                    iter_space = iter_sub_space_relation (     
                                    [access_relation.iter_space] )
                    data_space = access_relation.data_space
                    iterspace_to_data =  inverse 
                    ( iter_sub_space_relation compose (inverse access_relation))
                
                
            For the example, output is the following:
                access_relation_to_traverse = new AccessRelation
                    name = "A_II0_to_X0"
                    iter_space = { [ii] : 0 <= ii < n_inter  }
                    data_space = X0                    
                    iterspace_to_data := { [ii] -> [ inter1(ii) ] } 
                                       union { [ii] -> [ inter2(ii) ] }
                                 
                
        b) generate code that explicitly creates hypergraph and dual (if necessary) at runtime.
            input:
                access_relation_to_traverse (artt)
            output:
                code
                    // data index calc for each disjunct in access relation
                    #define s1(i_1, ..., i_d) data_index = ...; \
                        Hypergraph_ordered_insert_node([artt.name], \
                        count,data_index); \
                        count++;
                        
                    // initialize variables
                    Hypergraph* [artt.name] = Hypergraph_ctor();
                    int count=0;
                    int data_index=0;
                    
                    // loop that traverses [artt.iter_space]
                    for ...
                        s1(i_1, ..., i_d);
                        
                    Hypergraph_finalize([argtt.name]);
                    
           
            For the example, output is the following:
                    // this macro captures A_II0_to_X0, count, and data_index
                    #define s1(t1) data_index = inter1[t1]; \
                        Hypergraph_ordered_insert_node(A_II0_to_X0,count, \
                        data_index); \
                        data_index = inter2[t1]; \
                        Hypergraph_ordered_insert_node(A_II0_to_X0,count, \
                        data_index); \
                        count++
                        
                    // initialize variables
                    Hypergraph* A_II0_to_X0 = Hypergraph_ctor();
                    int count=0;
                    int data_index=0;
                    
                    // this specific example
                    for(t1 = 0; t1 <= n_inter-1; t1++) {
                        s1(t1);
                    }

                    Hypergraph_finalize(A_II0_to_X0);
                        
            algorithm:
                1) use omega codegen to generate loop over iteration sub space
                    codegen iter_sub_space;
                    
                2) generate a macro definition for the statement in the loop body from the relation_to_traverse
                    a) for each conjunct in the DNF // seem omega lib docs
                         -gen code that solves for the out variable, data_index, using the input iterator values
                         -gen code that makes the following call:
                            Hypergraph_ordered_insert_node( hgraph, iter_count, data_index )

        c) Automatically generate the IndexArray specification for sigma
            input:
                DataPermuteRTRT instance
                access_relation_to_traverse
                
            output:
                iag_spec = new IAG_Permute(
                    String name = rtrt.iag_func_name
                    AccessRelation input = access_relation_to_traverse
                    IndexArray result = new IndexArray(
                        data_space = [name of uninterp func in data_reordering],
                                     [specification from data space in RTRT],
                                     index array,
                        index_value_constraints = { [k] -> [ uninterp(k) ] : 
                            not [k has same bounds as data space] || 
                            [uninterp(k) has same bounds as data space] }   
                    )
                )
                        
            Initial Assumptions:
                -only one interpreted function in data reordering
                -that uninterpreted function has a domain with dimensionality 1
                    
        
            For this example:
                IAG_cpack = new IAG_Permute (
                    String name = "IAG_cpack"       // function name
                    AccessRelation input = A_II0_to_X0
                    IndexArray result = new IndexArray( 
                        data_space = "sigma", X_0.spec, index array,
                        index_value_constraints = { [k] -> [sigma(k)] : not (0 <= k <= (N-1)) || (0 <= sigma(k) <= (N-1)) }
                    )

                )        
        
        
        d) generate code that passes hypergraph to IAG
            input: 
                iag_spec
                
            output:
                code
                    [iag_spec.result.data_space.name] = malloc( ... );
                    [iag_spec.name]( [iag_spec.input.name],
                                     [iag_spec.result.data_space.name] );
                    
            For this example:
                    int *sigma;
                    MALLOC(sigma,int,N);
                    IAG_cpack( A_II0_to_X0, sigma );
                    
         
        e) generate code that does data reordering
        
        
        f) generate code that does pointer update
        
        
        
         
LEFTOFF: 

    - then we have to figure out whether to actually reorder the data or not and whether to do the pointer update.     
    
    