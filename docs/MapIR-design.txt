General notes



Need a MapIR specification.
    -MapIR
        - maps set and relation names to set and relation instances
        maybe even separate maps for each type.
            map<String,MapIRSet>
        
        class MapIR {
            IterSpace getIterSpace(String);
            void putIterSpace(String,IterSpace);
            
            DataSpace getDataSpace(String);
            
            IndexArray getIndexArray(String);
               
        }

        Questions
            - do we actually need to index the DataSpaces, IterSpaces, etc. by name?  Won't other data structures just have the data spaces in there?  I guess in the final representation that will be the case, but when parsing, need to treat the name like a symbol table, so a DataSpace can be referenced in other contexts.


    -One iteration space set.
        class IterSpace {
            String name;
            OmegaSet spec;
        }
        
        
    -The MapIR environment will contain multiple data spaces.  Also will want to know if a data space will contain the concrete realization for an uninterpreted symbol, which is the case for index arrays.  Have string identifier for the array data space and the corresponding uninterpreted function symbol be the same.
        class DataSpace {
            String name;
            bool is_index_array;
            OmegaSet spec;
        }
        
    
    -Each index array, which is mathematically represented with an uninterpreted function symbol, is specified with a relation where the domain  represents the uninterpreted function parameters and the single dimensional range represents the value of the uninterpreted function.  The relation constraints should indicate that if the parameters lie within certain boundaries, then the value of the uninterpreted function is also bounded.

        class IndexArray {
            DataSpace dataspace;    // reference to associated dataspace
            OmegaRelation index_value_constraints;
        }
    Checking
        - The dimensionality of the domain should match the dimensionality of the associated index array DataSpace.
        - For now we are assuming that the dimensionality of the range of the index array is one.
        
    -Access relations (used to be called data mappings) are relations where the domain is an iteration space (subspaces are specified with constraints) and the range is a data space.  Initially thought we might want to rename this to "access functions", but they are not functions.  We can have the same iteration mapping to multiple places in one array.  Decided to call it a relation versus a mapping, because mappings are usually synonymous with functions (http://en.wikipedia.org/wiki/Function_(mathematics)).  Using the term access to more clearly indicate the relationship between iterations and data.  Each iteration accesses various data locations.
    
        class AccessRelation {
            String name;            // need a name so can name hypergraph
            IterSpace iter_space;
            DataSpace data_space;
            OmegaRelation iterspace_to_data;
        }

    Checking
        - Can compare domain with iteration space and range with data space.
    
    
    -Data dependences are relations from subspaces in the iteration space to subspaces in the iteration space.  Should be represented as between full iteration space and itself.  Constraints will make it so that it is really just between subspaces.  The data dependence also stores what data space is inducing the dependence.
    
        class DataDependence {
            IterSpace iter_space;
            OmegaRelation dd;
            DataSpace data_space;
        }
        
    Checking
        - Can we check that given the iteration space, data spaces, and access functions, the given data dependence is valid?  Is it overly conservative?  optimistic?
        
-------------------------------------------------------------------        
Transformation Specification:

    All of the run-time reordering transformations (RTRTs) should derive from this base class.  For now just for conceptual organization.  We might need functionality or interface specifications later.
    
    An IAGspec is different than an RTRT because an IAGspec is a specification of a library routine that takes hypergraphs as input and generates indexed permutations and/or groupings.  The IAGspec could eventually have pre and post conditions.  The RTRT needs to keep track of data and iteration spaces involved in the reordering, and the RTRT will be responsible for generating the code that generates the hypergraph data structures that will be passed to the IAG library routine at runtime.

    
    class RTRT {
    }
    
    class DataPermuteRTRT extends RTRT {
        // reordering specification
        OmegaRelation data_reordering;

        // DataSpaces that should all be permuted in the same way.
        List<DataSpace> data_spaces;
        
        // AccessRelation, mapping of iterations to data that
        // needs to have hypergraph creation code generated
        AccessRelation access_relation;
        
        // Mapping of full iteration space to sub space of the 
        // iteration space that inspector should 
        // traverse when inspecting the access relation.
        OmegaRelation iter_sub_space_relation;
        
        // Generator for the index arrays that are represented 
        // as uninterpreted functions 
        // in the data reordering specification.
        // For now ASSUMING there is only one.
        IAGspec index_array_generator;
        
        // Codifying correctness?  How should we codify things like
        // the data space should be 1D?
    }
    
    class IterReorderingRTRT extends RTRT {
        // reordering specification
        OmegaRelation iter_reordering;

        // Iteration space that inspector should traverse and also that
        // is being reordered
        IterSpace iter_space;
        
        // AccessRelation, mapping of iterations to data that
        // needs to have hypergraph creation code generated
        AccessRelation access_relation;
        
        // Generator for the index arrays that are represented 
        // as uninterpreted functions 
        // in the iteration reordering specification.
        // For now ASSUMING there is only one.
        IAGspec index_array_generator;
        
        // Codifying correctness?  How should we codify things like
        // the data space should be 1D?
    }       
    

    // Base class
    // Index array generator specifications.
    class IAGspec {
    }
        
    
    //      IAG_Permute - specification for an IAG that 
    //          takes a hypergraph (and possibly use its dual) and 
    //          creates an index array containing a 
    //          permutation of either the nodes or hyperedges in 
    //          the hypergraph.
    
    class IAG_Permute extends IAGspec {
        AccessRelation input;
        String name;
        IndexArray result;
    }

FIXME: MMS, 5/23/08, only need IAG_Permute to work on the first part of the moldyn-FST composed transformation, so the rest of this still needs thought out

    //      IAG_Group - creates an index array that groups the space
    //          used to access the index array.
    //          Assuming for now that we are only applying these to iteration
    //          spaces.
    //      Don't want to make this abstract.  Instead, it can be used by
    //      any grouping that does not inspect access relations or data
    //      dependences.
    class IAG_Group {
        // return the space being grouped
        IterSpace getInputIterSpace();
        
        // return heuristic being used to perform the grouping
        Heuristic getHeuristic();
        
        // Return specification for the index array that will be the 
        // result of the grouping.  Won't know name but will know 
        // input and output constraints for the uninterpreted function.
        // Is this something that the IAG should be able to compute from
        // its various pieces of info, the input space being grouped,
        // and the Heuristic info?  What do we really want here?
        OmegaRelation getIndexArraySpec();
        
        // might have these members in the base class, 
        // but might just have this be an interface
        IterSpace input;
        Heuristic heuristic;
        IndexArray result;
    }
    
    // uses data dependences in iteration space
    class IAG_Wavefront : public IAG_Group {
        // Wavefront needs the set of data dependences between the
        // points in the input iteration space.
        DataDeps input_dd;
        
    }
    
    // uses data dependences in iter space and a seed partitioning
    // on a subspace of the iter space
    class IAG_SparseTiling : public IAG_Group {
        // take dependences, a mapping from iter to seed space 
        // and a partitioning of the seed space
        DataDeps input_dd;
        OmegaRelation iter_space_to_seed_space;
        IndexArray seed_partition;
    }
    
    
Initial assumptions:
    -single iteration space, but different heuristics can operate on subspaces within that iteration space
    -range of uninterpreted function symbol is single dimensional
    -data and index arrays are only one dimensional when first specified?  what about later?
    -a data space is either an index array or a data array but not both, not sure what being both would mean