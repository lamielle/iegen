moldyn-FST-v2.txt
-----------------
Started 7/29/08

Now that we have data and iteration reordering figured out in moldyn-data-iter-reord.txt and uninterp-functions.txt, here we show how to represent and generate inspector/executor code for a full sparse tiling of a simplified version of the moldyn benchmark.

  for (s=0; s<T; s++) {
	for (i=0; i<N; i++) {
		x[i] = fx[i]*1.25;
	}

    for (ii=0; ii<n_inter; ii++) {
        // simplified computations
        fx[inter1[ii]] += x[inter1[ii]] - x[inter2[ii]]; 
        fx[inter2[ii]] += x[inter1[ii]] - x[inter2[ii]]; 
    }
  }

Notes
    - detail for the algorithms referenced in here can be found in uninterp-operations.txt
    
    
-----------------------
What the user specifies
-----------------------
Iteration Space

    I_0 := { [s,k,i,j] : 0<=s && s<T && k=1 && j=1 && 0<=i && i<N  }
           union { [s,k,ii,j] : 0<=s && s<T && k=2 && j=1 && 0<=ii && ii<=(n_inter-1)  }
           union { [s,k,ii,j] : 0<=s && s<T && k=2 && j=2 && 0<=ii && ii<=(n_inter-1)  }

Symbolic Constants
	T					// number of time steps
    N                   // number of atoms
    n_inter             // number of interactions between atoms
    
    // uninterp functions for index arrays, 
    // [0..(n_inter-1)] indicates range of possible parameter values
    // [0:N] indicates range of possible values
    // FIXME: might want to use this approach of representing IndexArray
    // constraints versus using the OmegaRelation that we currently have
    // in the MapIR design.
    inter1([0..(n_inter-1)]):[0..N]    
    inter2([0..(n_inter-1)]):[0..N]    
                        

Data Spaces
    X_0 := name = "x", { [k] : 0 <= k <= (N-1) }, data array
    FX_0 := name = "fx", { [k] : 0 <= k <= (N-1) }, data array
    INTER1_0 := name = "inter1", { [k] : 0 <= k <= (n_inter-1) }, index array
    INTER2_0 := name = "inter2", { [k] : 0 <= k <= (n_inter-1) }, index array

Statements
    [s,1,i,1]  "`a7 = `a8 * 1.25;"
    [s,2,ii,1]  "`a1 += `a2 - `a3;" 
    [s,2,ii,2]  "`a4 += `a5 - `a6;" 


Access Relations
    These actually need to be specified per data access in each statement.

    statement   access#     DataSpace   AccessRelation
    [s,1,i,1]	a7          X_0	        { [s,x,i,j] -> [i] : x=1 && j=1 }
    [s,1,i,1]	a8          FX_0        { [s,x,i,j] -> [i] : x=1 && j=1 }
    
    [s,2,ii,1]  a1          FX_0       	{ [s,x,ii,j] -> [k] : x=2 && j=1 && k=inter1(ii) }
    [s,2,ii,1]  a2          X_0        	{ [s,x,ii,j] -> [k] : x=2 && j=1 && k=inter1(ii) }
    [s,2,ii,1]  a3          X_0        	{ [s,x,ii,j] -> [k] : x=2 && j=1 && k=inter2(ii) }
    
    [s,2,ii,2]  a4          FX_0       	{ [s,x,ii,j] -> [k] : x=2 && j=2 && k=inter2(ii) }
    [s,2,ii,2]  a5          X_0        	{ [s,x,ii,j] -> [k] : x=2 && j=2 && k=inter1(ii) }
    [s,2,ii,2]  a6          X_0        	{ [s,x,ii,j] -> [k] : x=2 && j=2 && k=inter2(ii) }
    

Data Dependences
	x[i] to x[inter1[ii]]: { [s,x,i,j] -> [s,y,ii,k] : x=1 && y=2 && ...

    Reduction dependences in ii loop.  It is important to indicate that there are reduction dependences however, because that means each iteration needs to be executed atomically if the loop is being parallelized.
    FIXME: how will we indicate reduction dependences?

Composition and choice of RTRTs
    data reordering
        DataPermuteRTRT
            data_reordering = { [ k ] -> [ r ] : r=sigma( k ) }
            iteration_space = I_0
            data_spaces = [ X_0, FX_0 ]
            access_relation = A_I0_to_X0
            iter_sub_space_relation = { [ s, k, ii, j ] -> [ ii ] }
            iag_func_name = CPackHyper
            iag_type = IAG_Permute
    
    iteration reordering
        IterPermuteRTRT
            iter_reordering = { [ s,x,i,y ] -> [ s,x,k,y ] : k = delta( i ) }
            iteration_space = I_0
            access_relation = A_I_0_to_X_1
            iag_func_name = LexMin
            iag_type = IAG_Permute
            
    iteration reordering: FST
        IterGroupRTRT (FIXME: what are the other fields for this guy?)
            iter_reordering = { [ s,x,i,y ] -> [ s,v,t,x,i,y ] : v=1 && x=1 && y=1 && t=theta(x,i) } 
                union { [ s,x,ii,y ] -> [ s,v,t,x,ii,y ] : v=1 && x=2 && 1<=y && y<=2 && t=theta(x,ii) }
            iteration_space = I_1
            access_relation = A_I_1_to_X_1
            iag_func_name = FST
            iag_type = IAG_Group
            
    iteration reordering: tilepack
