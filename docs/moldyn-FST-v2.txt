moldyn-FST-v2.txt
-----------------
Started 7/29/08

Now that we have data and iteration reordering figured out in moldyn-data-iter-reord.txt and uninterp-functions.txt, here we show how to represent and generate inspector/executor code for a full sparse tiling of a simplified version of the moldyn benchmark.

  for (s=0; s<T; s++) {
	for (i=0; i<N; i++) {
		x[i] = fx[i]*1.25;
	}

    for (ii=0; ii<n_inter; ii++) {
        // simplified computations
        fx[inter1[ii]] += x[inter1[ii]] - x[inter2[ii]]; 
        fx[inter2[ii]] += x[inter1[ii]] - x[inter2[ii]]; 
    }
  }

Notes
    - detail for the algorithms referenced in here can be found in uninterp-operations.txt
    
    
-----------------------
What the user specifies
-----------------------
Iteration Space

    I_0 := { [s,k,i,j] : 0<=s && s<T && k=1 && j=1 && 0<=i && i<N  }
           union { [s,k,ii,j] : 0<=s && s<T && k=2 && j=1 && 0<=ii && ii<=(n_inter-1)  }
           union { [s,k,ii,j] : 0<=s && s<T && k=2 && j=2 && 0<=ii && ii<=(n_inter-1)  }

Symbolic Constants
	T					// number of time steps
    N                   // number of atoms
    n_inter             // number of interactions between atoms
    
    // uninterp functions for index arrays, 
    // [0..(n_inter-1)] indicates range of possible parameter values
    // [0:N] indicates range of possible values
    // FIXME: might want to use this approach of representing IndexArray
    // constraints versus using the OmegaRelation that we currently have
    // in the MapIR design.
    inter1([0..(n_inter-1)]):[0..N]    
    inter2([0..(n_inter-1)]):[0..N]    
                        

Data Spaces
    X_0 := name = "x", { [k] : 0 <= k <= (N-1) }, data array
    FX_0 := name = "fx", { [k] : 0 <= k <= (N-1) }, data array
    INTER1_0 := name = "inter1", { [k] : 0 <= k <= (n_inter-1) }, index array
    INTER2_0 := name = "inter2", { [k] : 0 <= k <= (n_inter-1) }, index array

Statements
    [s,1,i,1]  "`a7 = `a8 * 1.25;"
    [s,2,ii,1]  "`a1 += `a2 - `a3;" 
    [s,2,ii,2]  "`a4 += `a5 - `a6;" 


Access Relations
    These actually need to be specified per data access in each statement.

    statement   access#     DataSpace   AccessRelation
    [s,1,i,1]	a7          X_0	        { [s,x,i,j] -> [i] : x=1 && j=1 }
    [s,1,i,1]	a8          FX_0        { [s,x,i,j] -> [i] : x=1 && j=1 }
    
    [s,2,ii,1]  a1          FX_0       	{ [s,x,ii,j] -> [k] : x=2 && j=1 && k=inter1(ii) }
    [s,2,ii,1]  a2          X_0        	{ [s,x,ii,j] -> [k] : x=2 && j=1 && k=inter1(ii) }
    [s,2,ii,1]  a3          X_0        	{ [s,x,ii,j] -> [k] : x=2 && j=1 && k=inter2(ii) }
    
    [s,2,ii,2]  a4          FX_0       	{ [s,x,ii,j] -> [k] : x=2 && j=2 && k=inter2(ii) }
    [s,2,ii,2]  a5          X_0        	{ [s,x,ii,j] -> [k] : x=2 && j=2 && k=inter1(ii) }
    [s,2,ii,2]  a6          X_0        	{ [s,x,ii,j] -> [k] : x=2 && j=2 && k=inter2(ii) }
    

Data Dependences
	x[i] to x[inter1[ii]]: { [s,x,i,j] -> [s,y,ii,k] : x=1 && y=2 && ...

    Reduction dependences in ii loop.  It is important to indicate that there are reduction dependences however, because that means each iteration needs to be executed atomically if the loop is being parallelized.
    FIXME: how will we indicate reduction dependences?

Composition and choice of RTRTs
    data reordering
        DataPermuteRTRT
            data_reordering = { [ k ] -> [ r ] : r=sigma( k ) }
            iteration_space = I_0
            data_spaces = [ X_0, FX_0 ]
            access_relation = A_I0_to_X0
            iter_sub_space_relation = { [ s, k, ii, j ] -> [ ii ] }
            iag_func_name = CPackHyper
            iag_type = IAG_Permute
    
    iteration reordering // permuting the ii loop
        IterPermuteRTRT
            iter_reordering = { [ s,x,i,y ] -> [ s,x,k,y ] : k = delta( i )  && x=2 }
            access_relation = A_I_0_to_X_1
            iag_func_name = LexMin
            iag_type = IAG_Permute
            
    iteration reordering: FST
    	seedpart = IAG_Group	// not an RTRT so no reordering occurs 
    		iter_sub_space_relation = { [ s,x,i,y ] -> [ i ] : x=2 }
    		iag_name = "Block"
    		params = [num_blocks]
    		result = new IndexArray(
                    data_space = "part", subspace PresSet, index array,
                    isPermutation = false,
                    input_value_bounds = [(0 .. (n_iter-1))],
                    output_value_bounds = (0 .. (num_blocks-1))
                )
    		
        IterGroupRTRT
            iter_reordering = { [ s,x,i,y ] -> [ s,v,t,x,i,y ] : v=1 && x=1 && y=1 && t=theta(x,i) } 
                union { [ s,x,ii,y ] -> [ s,v,t,x,ii,y ] : v=1 && x=2 && 1<=y && y<=2 && t=theta(x,ii) }
                // split because of different y's
            
            // seed partition the ii loop
            iter_space_to_seed_space = { [ s,x,i,y ] -> [ i ] : x=2 }
            
            // only inspect the dependences within one s iteration
            iter_sub_space_relation = { [ s,x,i,y ] -> [ s,x,i,y ] : s=0 }
            
            seed_part_gen = seedpart
            iag_func_name = FST
            
    iteration reordering: tilepack
    

------------------------------------------------------------
Automatically Generating Straight-Forward Inspector/Executor
------------------------------------------------------------

For data and iteration reordering see moldyn-data-iter-reord.txt.  Inputs have changed somewhat, but all code generation algorithms should still work.


8) seedpart = IAG_Group
	a) restrict iteration space to iteration sub space that will be grouped
	b) Automatically generate the IndexArray specification for part
	c) Generate code that calls IAG algorithm Block to generate values for part

9) IterGroupRTRT
	a) Calculate dependences between the seed space and the other part of the sub space to be tiled.
	b) Generate code to explicitly inspect those dependences.
	c) Pass the dependences into FST.
	d) Generate sparse schedule. (ITO so should plan with and without)
	e) Generate executor.
