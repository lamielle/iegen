# Set and Relation operations needed for M2 example.
# See RTRTJournalShared/moldyn-FST-example.tex for corresponding writeup.
# Also see iegen/example/moldyn-FST.spec

import cProfile
import pstats

import iegen
from iegen import Set
from iegen import Relation
from iegen import Symbolic

import iegen.simplify

##### Compose scheduling/scattering function for each statement
##### with the statement's original iteration space.
#iegen.simplify.registerInversePairs()

syms = [Symbolic("N"),Symbolic("T"), Symbolic("n_inter")]

# S1
print "==== S1"
S1_I = Set("{[s,i]: 0<=s && s<T && 0<=i && i<N}", syms)
print S1_I

S1_sched = Relation("{[s,i]->[c0,s,c1,j,c2]: c0=0 && c1=0 && c2=0 && i=j}")
print S1_sched

S1_full_I = S1_I.apply(S1_sched)
print S1_full_I

# S2
print "==== S2"
S2_I = Set("{[s,i]: 0<=s && s<T && 0<=i && i<n_inter}", syms)
print S2_I

S2_sched = Relation("{[s,i]->[c0,s,c1,j,c2]: c0=0 && c1=1 && c2=0 && i=j}")
print S2_sched

S2_full_I = S2_I.apply(S2_sched)
print S2_full_I

# S3
print "==== S3"
S3_I = Set("{[s,i]: 0<=s && s<T && 0<=i && i<n_inter}", syms)
print S3_I

S3_sched = Relation("{[s,i]->[c0,s,c1,j,c2]: c0=1 && c1=1 && c2=1 && i=j}")
print S3_sched

S3_full_I = S3_I.apply(S3_sched)
print S3_full_I

# full iteration space
print "==== Full Iteration Space"
full_I = S1_full_I.union(S2_full_I.union(S3_full_I))
print full_I

#### Modifying the access relations so that their source is the 
#### full iteration space.

# A1, access relation for S1, targets data array x
print "==== A1, access relation for S1"
a1 = Relation("{[s,i]->[j] : i=j}")
print a1
print "Modified a1"
a1_modified = a1.compose(S1_sched.inverse())
print a1_modified

# A4, access relation for S2, targets data array x
print "==== A4, access relation for S2"
a4 = Relation("{[s,i]->[k]: k=inter1(i)}")
print a4
print "Modified a4"
a4_modified = a4.compose(S2_sched.inverse())
print a4_modified

# A8, access relation for S3, targets data array x
print "==== A8, access relation for S3"
a8 = Relation("{[s,i]->[k]: k=inter2(i)}")
print a8
print "Modified a8"
a8_modified = a8.compose(S2_sched.inverse())
print a8_modified



#### DataPermuteTrans
print
print "==== DataPermuteTrans"

print "explicit relation specification generated by calc_input"
print "\tinput:"
print "\t\tall access relations that target data array x"
iter_sub_space_relation = Relation("{[c0,s,c1,i,c2]->[i] : c1=1}")
print "\t\titer_sub_space_relation = ", iter_sub_space_relation
print "\talgorithm:"
print "\t\tall_ar = union of all access relations"
all_ar = a1_modified.union( a4_modified.union( a8_modified ) )
print "\t\tall_ar = ", all_ar
print "\t\tars of interest = inverse (iter_sub_space_relation compose (inverse all_ar))"
print
#### PERFORMANCE PROBLEM: the following composition causes a noticable pause
print "\toutput:"
print "\t\tars of interest = " ,iter_sub_space_relation.compose( all_ar.inverse() ).inverse()
#cProfile.run('iter_sub_space_relation.compose( all_ar.inverse() ).inverse()','prof')
#p = pstats.Stats('prof')
#p.strip_dirs()
#p.sort_stats('cumulative').print_stats(20)
#p.sort_stats('time').print_stats(20)
#p.print_callers(20)
print
print
print "Update modified access relations based on automatically derived data reordering specification."
R_x0_x1 = Relation("{[k] -> [j] : j = sigma(k)}")
print "\tdata reordering specification (R_x0_x1) = ", R_x0_x1
print
print "\tR_x0_x1 compose a1_modified = "
print R_x0_x1.compose(a1_modified)
print
print "\tR_x0_x1 compose a8_modified = "
print R_x0_x1.compose(a8_modified)


#### Loop Alignment
print
print "==== Loop Alignment"
print "Waiting for f(f_inv(i)) simplification"


#### IterPermuteTrans
iegen.simplify.register_inverse_pair('delta')
print
print "==== IterPermuteTrans"
T_I0_to_I1 = Relation("{[c0,s1,c1,i,c2] -> [c3,s2,c4,j,c5] : s1=s2 && c0=0 && c1=0 && c2=0 && c3=0 && c4=0 && c5=0 && i=j}")
T_I0_to_I1 = T_I0_to_I1.union( Relation("{[c6,s3,c7,ii,x] -> [c8,s4,c9,j,y] : s3=s4 && j = delta(ii) && c6=0 && c8=0 && c7=1 && c9=1 && x=y }"))
print "T_I0_to_I1 = ", T_I0_to_I1
print
A_I_to_x = Relation("{[c10,s,c11,ii,c12] -> [r] : r = sigma(inter1(ii)) && c11=1 && c10=0 && c12=0}")
print "A_I_to_x = ", A_I_to_x
print
result = A_I_to_x.compose( T_I0_to_I1.inverse() )
print "A_I_to_x compose (inverse T_I0_to_I1) = ", result

#### SparseTileTrans
print
print "==== SparseTileTrans"
print "Data dependences to and from seed partitioning space."
print "Will be computed in calc_input method"
print "(See iegen/doc/sparse-tile-design.txt for algorithm)."
print
print "Input:"
print "\tDirect data dependences:"
D_1_2 = Relation("{[c0,s,c1,i,c2] -> [c0,s,c3,ii,c2] : i = inter1(ii) && c1=0 && c2=0 && c0=0 && c3=1}")
D_1_2 = D_1_2.union(Relation("{[c0,s,c1,i,c2] -> [c0,s,c3,ii,c2] : i = inter2(ii) && c1=0 && c2=0 && c0=0 && c3=1}"))
D_1_3 = D_1_2
D_2_1 = Relation("{[c0,s,c3,ii,c2] -> [c0,s,c1,i,c2] : s2 > s && i=inter1(ii) && c1=0 && c2=0 && c0=0 && c3=1}")
D_2_1 = D_2_1.union(Relation("{[c0,s,c3,ii,c2] -> [c0,s,c1,i,c2] : s2 > s && i = inter2(ii) && c1=0 && c2=0 && c0=0 && c3=1}"))
print "\t\tD_1_2 = D_1_3 = ", D_1_2
print "\t\tD_2_1 = ", D_2_1
print "\t\tfull_I = ", full_I
iter_sub_space_relation = Relation("{[c0,s,x,i,y]->[x,i]}")
iter_seed_space_relation = Relation("{[c0,s,c1,i,c2]->[i] : c1=1}")
print "\t\titer_sub_space_relation = ", iter_sub_space_relation
print "\t\titer_seed_space_relation = ", iter_seed_space_relation
print
print "Algorithm:"
print "\t\t# Dependences that exist within space being sparse tiled"
D = D_1_3.union(D_2_1)
D_ST = iter_sub_space_relation.compose(iter_sub_space_relation.compose(D).inverse()).inverse()
print "\t\tD_ST = ", D_ST
print
print "\t\tNOTE: not doing verification that dependences in D_ST are not loop carried because I don't know how to iterate over the disjuntions or in and out tuples yet."
D_ST_0 = D_ST
print "D_ST_0 = D_ST = ", D_ST_0
print "D_ST_0 compose D_ST = ", D_ST_0.compose(D_ST)
D_ST_1 = D_ST_0.compose(D_ST).union(D_ST)
print "D_ST_1 = (D_ST_0 compose D_ST) union D_ST = ", D_ST_1

print "Output:"
print "\tFROM_SS = "
print "\tTO_SS = "



