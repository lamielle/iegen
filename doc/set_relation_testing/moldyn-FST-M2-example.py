# Set and Relation operations needed for M2 example.
# See RTRTJournalShared/moldyn-FST-example.tex for corresponding writeup.
# Also see iegen/example/moldyn-FST.spec

import iegen
from iegen import Set
from iegen import Relation
from iegen import Symbolic

##### Compose scheduling/scattering function for each statement
##### with the statement's original iteration space.

syms = [Symbolic("N"),Symbolic("T"), Symbolic("n_inter")]

# S1
print "==== S1"
S1_I = Set("{[s,i]: 0<=s && s<T && 0<=i && i<N}", syms)
print S1_I

S1_sched = Relation("{[s,i]->[c0,s,c1,i,c2]: c0=0 && c1=0 && c2=0}")
print S1_sched

S1_full_I = S1_I.apply(S1_sched)
print S1_full_I

# S2
print "==== S2"
S2_I = Set("{[s,i]: 0<=s && s<T && 0<=i && i<n_inter}", syms)
print S2_I

S2_sched = Relation("{[s,i]->[c0,s,c1,i,c2]: c0=0 && c1=1 && c2=0}")
print S2_sched

S2_full_I = S2_I.apply(S2_sched)
print S2_full_I

# S3
print "==== S3"
S3_I = Set("{[s,i]: 0<=s && s<T && 0<=i && i<n_inter}", syms)
print S3_I

S3_sched = Relation("{[s,i]->[c0,s,c1,i,c2]: c0=1 && c1=1 && c2=1}")
print S3_sched

S3_full_I = S3_I.apply(S3_sched)
print S3_full_I

# full iteration space
print "==== Full Iteration Space"
full_I = S1_full_I.union(S2_full_I.union(S3_full_I))
print full_I

#### Modifying the access relations so that their source is the 
#### full iteration space.

# A1, access relation for S1, targets data array x
print "==== A1, access relation for S1"
a1 = Relation("{[s,i]->[i]}")
print a1
print "Modified a1"
a1_modified = a1.compose(S1_sched.inverse())
print a1_modified

# A4, access relation for S2, targets data array x
print "==== A4, access relation for S2"
a4 = Relation("{[s,i]->[k]: k=inter1(i)}")
print a4
print "Modified a1"
a4_modified = a4.compose(S2_sched.inverse())
print a4_modified

# A8, access relation for S3, targets data array x
print "==== A8, access relation for S3"
a8 = Relation("{[s,i]->[k]: k=inter2(i)}")
print a8
print "Modified a1"
a8_modified = a8.compose(S2_sched.inverse())
print a8_modified



#### DataPermuteTrans
print
print "==== DataPermuteTrans"

print "explicit relation specification generated by calc_input"
print "\tinput:"
print "\t\tall access relations that target data array x"
iter_sub_space_relation = Relation("{[c0,s,c1,i,c2]->[i] : c1=2}")
print "\t\titer_sub_space_relation = ", iter_sub_space_relation
print "\talgorithm:"
all_ar = a1_modified.union( a4_modified.union( a8_modified ) )
print "\t\tall_ar = ", all_ar
print "\t\tinverse (iter_sub_space_relation compose (inverse all_ar))"
print iter_sub_space_relation.compose( all_ar.inverse() ).inverse()
print "\toutput:"

# BUG (3/23/09): output should be something like 
# {[ii] -> [k] : k=inter1(ii)} 
# union {[ii] -> [k] : k=inter2(ii) }
# Is the problem that I did the union first?  
# This of course should not be an issue.  But see below that it isn't just that.

print iter_sub_space_relation.compose( a8_modified.inverse() ).inverse()


