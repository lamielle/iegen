Overview of how permutations are handled.

    RTRT list as specified by the user (part of MapIR)
        (A) DataPermuteRTRT({ [ k ] -> [ r ] : r=sigma( k ) }, [ X_0, FX_0 ],
                            { [ ii, j ] -> [ ii ] }, X_0, "IAG_cpack")
                        
        (B) IterPermuteRTRT({ [ i,x ] -> [ k,x ] : k = delta( i ) },
                            { [ ii, j ] -> [ ii ] }, X_0, "IAG_lexmin")

            |
            |
    Perform calculation traversal of RTRT list.
        1A) Call calc_input on (A) and it will return the static description of any relations that need to be explicitly generated and passed to IAG_cpack.      
        
        2A) Call calc_output on (A) and it will return the static description of its output, which for a permutation is a relation that describes the uninterpreted function with the uninterpreted function.  The point is simply to have a static relation description for the uninterpreted function symbol and a static description of the ER that will contain the uninterpreted function symbol at runtime.
        
        3A) Call calc_data_reord((A),mapIR) so that scattering functions and access relations are updated.
        
        1B) Call calc_input on (B) and it will return the static description of any relations that need to be explicitly generated and passed to IAG_lexmin.      
        
        2B) Call calc_output on (B) and it will return the static description of its output, which for a permutation is a relation that describes the uninterpreted function with the uninterpreted function.  The point is simply to have a static relation description for the uninterpreted function symbol and a static description of the ER that will contain the uninterpreted function symbol at runtime.
        
        3B) Call calc_iter_reord((A),mapIR) so that scattering functions and access relations are updated appropriately.
        
            |
            |
            v
            
            
    RTRT list after input and output relations have been computed 
    
        (A) DataPermuteRTRT({ [ k ] -> [ r ] : r=sigma( k ) }, [ X_0, FX_0 ],
                            { [ ii, j ] -> [ ii ] }, X_0, "IAG_cpack")
            PRE ERs: artt = {[ii] -> [k] : k=inter1(ii)} 
                            union {[ii] -> [k] : k=inter2(ii) }
            Output ERs: sigma_ER = {[i] -> [j] : j=sigma(i)}
            
            POST ERs: (none, but if removing all existentially quantified variables require the run-time creation of ERs, then a static description of those ERs would be put in this list.)

            scatter and access relations after calc_data_reord:
                example, { [ii] -> [ r ] : r=sigma( inter1(ii) ) }
    
    
        (B) IterPermuteRTRT({ [ i,x ] -> [ k,x ] : k = delta( i ) },
                            { [ ii, j ] -> [ ii ] }, X_0, "IAG_lexmin")
                        
            PRE ERs: artt = { [ii] -> [ sigma(inter1(ii)) ] }
                            union { [ii] -> [ sigma(inter2(ii)) ] }
                            
            Output ERs: delta_ER = {[i] -> [j] : j=delta(i)}
            
            POST ERs:
                delta_inv_ER = { [i] -> [j] : i = delta(j) && j bounds }    
                // need way to iterate over range of output tuples
    
            scatter and access relations after calc_data_reord:
                example, { [a,b] -> [r] : r=sigma(inter1(delta_inv(a))) && 1 <=b<=2}
            

            |
            |
            
    (OPTIONAL but probably important for performance)        
    Perform collapsing of nested uninterpreted functions optimization.
        Pass 1) finds sigma(inter1(x)) and sigma(inter2(x)) nests ands associated relation to POST ERs for (A), but does static substitution on all following relations.
        
        Pass 2) finds inter1_prime(delta_inv(x)) and inter2_prime(delta_inv(x)) nests ands associated relation to POST ERs for (B).
                
            |
            |
            v
            
            
    RTRT list after collapsing optimization. 
    
        (A) DataPermuteRTRT({ [ k ] -> [ r ] : r=sigma( k ) }, [ X_0, FX_0 ],
                            { [ ii, j ] -> [ ii ] }, X_0, "IAG_cpack")
            PRE ERs: artt = {[ii] -> [k] : k=inter1(ii)} 
                            union {[ii] -> [k] : k=inter2(ii) }
            Output ERs: sigma_ER = {[i] -> [j] : j=sigma(i)}
            
            POST ERs: 
                inter1_prime = { [i] -> [j] : j = sigma(inter1(i)) && i bounds }
                inter2_prime = { [i] -> [j] : j = sigma(inter2(i)) && i bounds }

            scatter and access relations after calc_data_reord:
                example, { [ii] -> [ r ] : r=sigma( inter1(ii) ) }
                
            scatter and access relations after collapsing:
                example, { [ii] -> [ r ] : r=inter1_prime(ii)  }
    
    
        (B) IterPermuteRTRT({ [ i,x ] -> [ k,x ] : k = delta( i ) },
                            { [ ii, j ] -> [ ii ] }, X_0, "IAG_lexmin")
                        
            PRE ERs: artt = { [ii] -> [ sigma(inter1(ii)) ] }
                            union { [ii] -> [ sigma(inter2(ii)) ] }
                            
            PRE ERs after collapsing: 
                     artt = { [ii] -> [ inter1_prime(ii) ] }
                            union { [ii] -> [ inter2_prime(ii) ] }
                            
            Output ERs: delta_ER = {[i] -> [j] : j=delta(i)}
            
            POST ERs:
                delta_inv_ER = { [i] -> [j] : i = delta(j) && j bounds }    
                // FIXME: need way to iterate over range of output tuples

                inter1_prime_prime 
                    = { [i] -> [j] : j = inter1_prime(delta_inv(x)) && i bounds}
                inter2_prime_prime 
                    = { [i] -> [j] : j = inter2_prime(delta_inv(x)) && i bounds}
                // FIXME: need a different naming scheme
                
            scatter and access relations after calc_data_reord:
                example, { [a,b] -> [r] : r=sigma(inter1(delta_inv(a))) && 1 <=b<=2}

            scatter and access relations after first pass of collapsing:
                example, { [a,b] -> [r] : r=inter1_prime(delta_inv(a)) && 1 <=b<=2}
            
            scatter and access relations after second pass of collapsing:
                example, { [a,b] -> [r] : r=inter1_prime_prime(a) && 1 <=b<=2}
            

            |
            |
            
    Compose data reorderings
                
            |
            |
            v
        
