/* Driver for code generated by the moldyn_fst.spec IEGen spec file. */
/* To compile, run the following commands from the root of the iegen source tree: */
/* For no transformations: iegen/bin/iegen examples/moldyn_fst.spec -o examples/moldyn_fst_notrans.c --inspector-name=inspector_notrans --executor-name=executor_notrans*/
/* For no transformations: iegen/bin/iegen examples/moldyn_fst.spec -o examples/moldyn_fst_trans.c --inspector-name=inspector_trans --executor-name=executor_trans*/
/* g++ ./examples/moldyn_fst_driver.c -g -I./src/dev src/dev/ExplicitRelation.c src/dev/RectDomain.c src/dev/util.c src/dev/ERG_cpack.c -o ./examples/moldyn_fst
_driver && ./examples/moldyn_fst_driver */

#include <stdio.h>
#include <stdlib.h>

#include "ExplicitRelation.h"
#include "ERG.h"
#include "util.h"

#define max(a,b) (((a)>(b))?(a):(b))
#define min(a,b) (((a)<(b))?(a):(b))

void null_data(double **x,double **fx,int **inter1,int **inter2)
{
	/* Set data/index arrays to NULL */
	*x=NULL; *fx=NULL;
	*inter1=NULL; *inter2=NULL;
}

void alloc_data(double **x,double **fx,int **inter1,int **inter2,int N,int n_inter)
{
	/* Set data/index arrays to NULL*/
	null_data(x,fx,inter1,inter2);

	/* Allocate space for data/index arrays */
	*x=(double*)malloc(sizeof(double)*N);
	*fx=(double*)malloc(sizeof(double)*N);
	*inter1=(int*)malloc(sizeof(int)*n_inter);
	*inter2=(int*)malloc(sizeof(int)*n_inter);
}

void free_data(double **x,double **fx,int **inter1,int **inter2)
{
	/* Free space allocated for data/index arrays */
	free(*x);
	free(*fx);
	free(*inter1);
	free(*inter2);

	/* Set data/index arrays to NULL */
	null_data(x,fx,inter1,inter2);
}

void init_data(double *x,double *fx,int *inter1,int *inter2,int N,int n_inter)
{
	int i;

	/* Init data arrays */
	for(i=0;i<N;i++)
	{
		x[i]=i;
		fx[i]=i*2;
	}

	/* Init index arrays */
	for(i=0;i<n_inter;i++)
	{
		inter1[i]=i;
		inter2[i]=n_inter-i-1;
	}
}

void print_int_array(int *array,int len)
{
	int i;
	for(i=0;i<len;i++) printf("%d ",array[i]);
}

void print_double_array(double *array,int len)
{
	int i;
	for(i=0;i<len;i++) printf("%f ",array[i]);
}

void print_data(double *x,double *fx,int *inter1,int *inter2,int N,int n_inter)
{
	printf("x:      "); print_double_array(x,N); printf("\n");
	printf("fx:     "); print_double_array(fx,N); printf("\n");
	printf("inter1: "); print_int_array(inter1,n_inter); printf("\n");
	printf("inter2: "); print_int_array(inter2,n_inter); printf("\n");
}

void executor_orig(double *x,double *fx,int *inter1,int *inter2,int T,int N,int n_inter)
{
	int s,i;

	for(s=0; s<T; s++)
	{
		for(i=0; i<N; i++)
		{
			x[i] = fx[i] * 1.25;
		}

		for(i=0; i<n_inter; i++)
		{
			fx[inter1[i]] += x[inter1[i]] - x[inter2[i]];
			fx[inter2[i]] += x[inter1[i]] - x[inter2[i]];
		}
	}
}

/* Include the untransformed code */
#include "moldyn_fst_notrans.c"

/* Include the transformed code */
#include "moldyn_fst_trans.c"

int main()
{
	/* Symbolic constants */
	int T=1,N=10,n_inter=5;

	/* Data arrays */
	double *x_orig,*fx_orig,*x_notrans,*fx_notrans,*x_trans,*fx_trans;

	/* Index arrays */
	int *inter1_orig,*inter2_orig,*inter1_notrans,*inter2_notrans,*inter1_trans,*inter2_trans;

	/* Explicit relations */
	ExplicitRelation **sigma;

	int i;

	/* Allocate data/index arrays */
	printf("Allocating data/index arrays... ");
	alloc_data(&x_orig,&fx_orig,&inter1_orig,&inter2_orig,N,n_inter);
	alloc_data(&x_notrans,&fx_notrans,&inter1_notrans,&inter2_notrans,N,n_inter);
	alloc_data(&x_trans,&fx_trans,&inter1_trans,&inter2_trans,N,n_inter);
	printf("done\n");

	/* Init data/index arrays */
	printf("Initializing data/index arrays... ");
	init_data(x_orig,fx_orig,inter1_orig,inter2_orig,N,n_inter);
	init_data(x_notrans,fx_notrans,inter1_notrans,inter2_notrans,N,n_inter);
	init_data(x_trans,fx_trans,inter1_trans,inter2_trans,N,n_inter);
	printf("done\n");


	/* Print data/index arrays before original computation */
	printf("Before original computation: \n");
	print_data(x_orig,fx_orig,inter1_orig,inter2_orig,N,n_inter);

	/* Perform the original computation */
	printf("Performing original computation... ");
	executor_orig(x_orig,fx_orig,inter1_orig,inter2_orig,T,N,n_inter);
	printf("done\n");

	/* Print data/index arrays after original computation */
	printf("After original computation: \n");
	print_data(x_orig,fx_orig,inter1_orig,inter2_orig,N,n_inter);


	/* Print data/index arrays before untransformed computation */
	printf("Before untransformed computation: \n");
	print_data(x_notrans,fx_notrans,inter1_notrans,inter2_notrans,N,n_inter);

	/* Perform the untransformed computation */
	printf("Performing untransformed computation... ");
	executor_notrans(fx_notrans,N,x_notrans,inter1_notrans,inter2_notrans,T,n_inter);
	printf("done\n");

	/* Print data/index arrays after untransformed computation */
	printf("After untransformed computation: \n");
	print_data(x_notrans,fx_notrans,inter1_notrans,inter2_notrans,N,n_inter);


	/* Print data/index arrays before transformed computation */
	printf("Before transformed computation: \n");
	print_data(x_trans,fx_trans,inter1_trans,inter2_trans,N,n_inter);

	/* Perform the transformed computation */
	printf("Calling inspector for transformed computation... ");
	inspector_trans(fx_trans,N,x_trans,T,n_inter,inter2_trans,inter1_trans,sigma);
	printf("done\n");
	printf("Performing transformed computation... ");
	executor_trans(fx_trans,N,x_trans,T,n_inter,inter2_trans,inter1_trans,sigma);
	printf("done\n");

	/* Print data/index arrays after transformed computation */
	printf("After transformed computation: \n");
	print_data(x_trans,fx_trans,inter1_trans,inter2_trans,N,n_inter);


	/* Free space allocated for data/index arrays */
	free_data(&x_orig,&fx_orig,&inter1_orig,&inter2_orig);
	free_data(&x_notrans,&fx_notrans,&inter1_notrans,&inter2_notrans);
	free_data(&x_trans,&fx_trans,&inter1_trans,&inter2_trans);
}
